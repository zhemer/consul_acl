package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"github.com/hashicorp/consul/api"
	"io/ioutil"
	"log"
	"os"
	"reflect"
	"sort"
	"time"
)

const (
	sVer     = "0.0.3"
	sAddrDef = "localhost"
)

// Refactored struct for JSON generated by https://github.com/bashtian/jsonutils
type PolicyS struct {
	Descr string `json:"Descr"`
	Name  string `json:"Name"`
	Rules string `json:"Rules"`
}
type RoleS struct {
	Descr    string   `json:"Descr"`
	Name     string   `json:"Name"`
	Policies []string `json:"Policies"`
}
type TokenS struct {
	Descr    string   `json:"Descr"`
	Policies []string `json:"Policies"`
	Roles    []string `json:"Roles"`
	Token    string   `json:"Token"`
}
type ConsulAcl struct {
	Policy []PolicyS
	Role   []RoleS
	Token  []TokenS
}

var (
	sFileAcl = flag.String("f", "", "JSON file name with Consul ACL set")
	sAddr    = flag.String("a", sAddrDef, "Consul server address")
	sToken   = flag.String("t", "", "ACL agent token")
	iDebug   = flag.Bool("d", false, "Tune on verbose output")
)

func main() {
	flag.Usage = func() {
		fmt.Fprintf(flag.CommandLine.Output(), "Maintain Consul's ACL in required state, described in JSON file specified by -f parameter\nVersion %s\n", sVer)
		fmt.Fprintf(flag.CommandLine.Output(), "Usage: %s -f <file> [-d]\n", os.Args[0])
		flag.PrintDefaults()
		// fmt.Fprintf(flag.CommandLine.Output(), "\n"+sHelp)
	}
	flag.Parse()
	if *sFileAcl == "" {
		fmt.Printf("You must specify file in JSON format\n")
		flag.Usage()
		return
	}

	// Read ACL JSON list
	data, err := ioutil.ReadFile(*sFileAcl)
	if err != nil {
		log.Fatal(err)
	}
	if !json.Valid(data) {
		log.Fatal(*sFileAcl + ": invalid JSON format\n")
	}

	var aclList ConsulAcl
	err = json.Unmarshal([]byte(data), &aclList)
	if err != nil {
		log.Fatal(err)
	}

	Log("aclList %v\n\n", aclList)

	// Creating policy hash from parsed JSON
	aclPol := map[string]PolicyS{}
	for _, v := range aclList.Policy {
		Log("--- %q\n", v)
		aclPol[v.Name] = v
	}
	Log("== aclPol %q\n\n", aclPol)

	// Creating role hash from parsed JSON
	aclRole := map[string]RoleS{}
	for _, v := range aclList.Role {
		Log("--- %q\n", v)
		aclRole[v.Name] = v
	}
	Log("== aclRole %q\n\n", aclRole)

	// Creating token hash from parsed JSON
	aclToken := map[string]TokenS{}
	for _, v := range aclList.Token {
		Log("--- %q\n", v)
		aclToken[v.Descr] = v
	}
	Log("== aclToken %q\n\n", aclToken)

	// ==============================================
	// Connection to Consul
	// ==============================================
	// Get a new client
	config := api.DefaultConfig()
	time30s, _ := time.ParseDuration("30s")
	config.WaitTime = time30s
	if *sToken != "" {
		config.Token = *sToken
	}

	if *sAddr != sAddrDef {
		config.Address = *sAddr + ":8500"
	}
	client, err := api.NewClient(config)
	if err != nil {
		Log("config %v\n", config)
		panic(err)
	}

	acl := client.ACL()

	// ===========================================================
	// Policy
	// ===========================================================
	aclPol1 := map[string]string{}
	aclPolList, wm, err := acl.PolicyList(nil)
	if err != nil {
		log.Fatal(err)
	}
	Log("==== acl.PolicyList %v %v %v\n", aclPolList, wm, err)
	for _, pol := range aclPolList {
		policy, _, err := acl.PolicyRead(pol.ID, nil)
		Log("== acl.PolicyRead(pol.ID=%v) aclPolicy=%v err=%v\n\n", pol.ID, policy, err)
		if aclPol[pol.Name].Descr == "skip" {
			Log("Skipping policy %q\n", pol.Name)
			delete(aclPol, pol.Name)
			continue
		}
		if aclPol[pol.Name].Name == "" {
			_, err := acl.PolicyDelete(pol.ID, nil)
			if err != nil {
				log.Fatalf("%v: %q\n", err, pol)
			} else {
				fmt.Printf("Removed policy %q\n", pol.Name)
			}
			continue
		}
		aclPol1[pol.Name] = pol.ID
		if policy.Rules != aclPol[pol.Name].Rules || policy.Description != aclPol[pol.Name].Descr {
			policy.Rules = aclPol[pol.Name].Rules
			policy.Description = aclPol[pol.Name].Descr
			_, _, err := acl.PolicyUpdate(policy, nil)
			if err != nil {
				log.Fatal(err)
				log.Fatalf("%v: %q\n", err, pol)
			} else {
				fmt.Printf("Updated policy %q\n", pol.Name)
			}
		}

	}
	for k, v := range aclPol {
		// Log("=== %q %q\n", k, v)
		// if v.Descr == "skip" {
		// 	continue
		// }
		if aclPol1[k] == "" {
			_, _, err := acl.PolicyCreate(&api.ACLPolicy{Name: k, Rules: v.Rules, Description: v.Descr}, nil)
			if err != nil {
				log.Fatal(err)
				log.Fatalf("%v: %q\n", err, v)
			} else {
				fmt.Printf("Created policy %q\n", k)
			}

		}
	}
	Log("\n")

	// ===========================================================
	// Role
	// ===========================================================
	aclRole1 := map[string]string{}
	aclRoleList, wm, err := acl.RoleList(nil)
	if err != nil {
		log.Fatal(err)
	}
	Log("==== acl.RoleList %v %v %v\n", aclRoleList, wm, err)
	for _, role := range aclRoleList {
		role, _, err := acl.RoleRead(role.ID, nil)
		Log("== acl.RoleRead(role.ID=%v) aclRole=%v err=%v\n\n", role.ID, role, err)
		if aclRole[role.Name].Descr == "skip" {
			Log("Skipping role %q\n", role.Name)
			delete(aclRole, role.Name)
			continue
		}
		if aclRole[role.Name].Name == "" {
			_, err := acl.PolicyDelete(role.ID, nil)
			if err != nil {
				log.Fatalf("%v: %q\n", err, role)
			} else {
				fmt.Printf("Removed role %q\n", role.Name)
			}
			continue
		}
		aclRole1[role.Name] = role.ID
		pl := []string{}
		for _, p := range role.Policies {
			pl = append(pl, p.Name)
		}
		sort.Strings(pl)
		sort.Strings(aclRole[role.Name].Policies)
		if reflect.DeepEqual(pl, aclRole[role.Name].Policies) == false || role.Description != aclRole[role.Name].Descr {
			pols := []*api.ACLLink{}
			for _, p := range aclRole[role.Name].Policies {
				pols = append(pols, &api.ACLLink{ID: aclPol1[p], Name: p})
			}

			role.Policies = pols
			Log("pols %v\n", pols)
			role.Description = aclRole[role.Name].Descr
			_, _, err := acl.RoleUpdate(role, nil)
			if err != nil {
				log.Fatal(err)
				log.Fatalf("%v: %q\n", err, role)
			} else {
				fmt.Printf("Updated role %q\n", role.Name)
			}
		}

	}
	for k, v := range aclRole {
		// Log("=== %q %q\n", k, v)
		// if v.Descr == "skip" {
		// 	continue
		// }
		if aclRole1[k] == "" {
			pols := []*api.ACLLink{}
			for _, p := range aclRole[k].Policies {
				pols = append(pols, &api.ACLLink{ID: aclPol1[p], Name: p})
			}
			_, _, err := acl.RoleCreate(&api.ACLRole{Name: k, Policies: pols, Description: v.Descr}, nil)
			if err != nil {
				log.Fatal(err)
				log.Fatalf("%v: %q\n", err, v)
			} else {
				fmt.Printf("Created role %q\n", k)
			}

		}
	}
	Log("\n")

	// ===========================================================
	// Token
	// ===========================================================
	aclToken1 := map[string]string{}
	aclTokenList, wm, err := acl.TokenList(nil)
	if err != nil {
		log.Fatal(err)
	}
	Log("==== acl.TokenList %v %v %v\n", aclTokenList, wm, err)
	for _, token := range aclTokenList {
		token, _, err := acl.TokenRead(token.AccessorID, nil)
		Log("== acl.TokenRead(token.AccessorID=%v) aclToken=%v err=%v\n\n", token.AccessorID, token, err)

		// Skipping control token
		if aclToken[token.Description].Token == "skip" {
			Log("Skipping token %q\n", token.Description)
			delete(aclToken, token.Description)
			continue
		}

		// Removing unknown and legacy tokens
		if aclToken[token.Description].Descr == "" || len(token.Rules) > 0 {
			_, err := acl.TokenDelete(token.AccessorID, nil)
			if err != nil {
				log.Fatalf("%v: %q\n", err, token)
				log.Fatalf("%v: %v(%v)\n", err, token.Description, token.AccessorID)

			} else {
				fmt.Printf("Removed token %q\n", token.Description)
			}
			continue
		}

		aclToken1[token.Description] = token.AccessorID

	}

	// Creating absent tokens
	for k, v := range aclToken {
		if aclToken1[k] == "" {
			poList := CreatePolicyRoleList(aclPol1, v.Policies)
			roList := CreatePolicyRoleList(aclRole1, v.Roles)
			_, _, err := acl.TokenCreate(&api.ACLToken{AccessorID: v.Token, SecretID: v.Token, Description: v.Descr,
				Policies: poList, Roles: roList}, nil)
			if err != nil {
				log.Fatalf("%v: %v\n", err, v)
			} else {
				fmt.Printf("Created token %q\n", v)
			}
		}
	}
	// Token end

} // main

func CreatePolicyRoleList(prList map[string]string, list []string) []*api.ACLLink {
	pr := []*api.ACLLink{}
	for _, p := range list {
		pr = append(pr, &api.ACLLink{ID: prList[p], Name: p})
	}
	return pr
}

func Log(format string, a ...interface{}) {
	if *iDebug == true {
		fmt.Printf(format, a...)
	}
}
