package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"github.com/hashicorp/consul/api"
	"io/ioutil"
	"log"
	"os"
	"reflect"
	"sort"
	"time"
)

const (
	sVer       = "0.0.4"
	sAddrDef   = "localhost"
	sKip       = "skip"
	sTokAnon   = "Anonymous Token"
	sTokMaster = "Master Token"
)

// Refactored struct for JSON generated by https://github.com/bashtian/jsonutils
type PolicyS struct {
	Descr string `json:"Descr"`
	Name  string `json:"Name"`
	Rules string `json:"Rules"`
}
type RoleS struct {
	Descr    string   `json:"Descr"`
	Name     string   `json:"Name"`
	Policies []string `json:"Policies"`
}
type TokenS struct {
	Descr    string   `json:"Descr"`
	Policies []string `json:"Policies"`
	Roles    []string `json:"Roles"`
	Token    string   `json:"Token"`
}
type ConsulAcl struct {
	Policy []PolicyS
	Role   []RoleS
	Token  []TokenS
}

var (
	sFileAcl = flag.String("f", "", "JSON file name with Consul ACL set")
	sAddr    = flag.String("a", sAddrDef, "Consul server address")
	sToken   = flag.String("t", "", "ACL agent token")
	iDebug   = flag.Bool("d", false, "Tune on verbose output")
)

func main() {
	flag.Usage = func() {
		fmt.Fprintf(flag.CommandLine.Output(), "Maintain Consul's ACL in required state, described in JSON file specified by -f parameter\nVersion %s\n", sVer)
		fmt.Fprintf(flag.CommandLine.Output(), "Usage: %s -f <file> [-d]\n", os.Args[0])
		flag.PrintDefaults()
		// fmt.Fprintf(flag.CommandLine.Output(), "\n"+sHelp)
	}
	flag.Parse()
	if *sFileAcl == "" {
		fmt.Printf("You must specify file in JSON format\n")
		flag.Usage()
		return
	}

	// Read ACL JSON list
	data, err := ioutil.ReadFile(*sFileAcl)
	if err != nil {
		log.Fatal(err)
	}
	if !json.Valid(data) {
		log.Fatal(*sFileAcl + ": invalid JSON format\n")
	}

	var aclList ConsulAcl
	err = json.Unmarshal([]byte(data), &aclList)
	if err != nil {
		log.Fatal(err)
	}

	Log("aclList %v\n\n", aclList)

	// Creating policy hash from parsed JSON
	aclPol := map[string]PolicyS{}
	for _, v := range aclList.Policy {
		Log("--- %q\n", v)
		aclPol[v.Name] = v
	}
	Log("== aclPol %q\n\n", aclPol)

	// Creating role hash from parsed JSON
	aclRole := map[string]RoleS{}
	for _, v := range aclList.Role {
		Log("--- %q\n", v)
		aclRole[v.Name] = v
	}
	Log("== aclRole %q\n\n", aclRole)

	// Creating token hash from parsed JSON
	aclToken := map[string]TokenS{}
	for _, v := range aclList.Token {
		Log("--- %q\n", v)
		aclToken[v.Descr] = v
	}
	Log("== aclToken %q\n\n", aclToken)

	// ==============================================
	// Connect to Consul
	// ==============================================
	// Get a new client
	config := api.DefaultConfig()
	time30s, _ := time.ParseDuration("30s")
	config.WaitTime = time30s
	if *sToken != "" {
		config.Token = *sToken
	}

	if *sAddr != sAddrDef {
		config.Address = *sAddr + ":8500"
	}
	client, err := api.NewClient(config)
	if err != nil {
		Log("config %v\n", config)
		panic(err)
	}

	acl := client.ACL()

	// aclList1, err1 := PolicyRead(acl)
	// if err != nil {
	// 	log.Fatal("err1 %v\n", err1)
	// }
	// for _, p := range aclList1 {
	// 	fmt.Printf("== p == %v\n", p)
	// }
	// return

	// ===========================================================
	// Policy
	// ===========================================================
	aclPol1 := map[string]string{}
	aclPolList, err := PolicyRead(acl)
	if err != nil {
		log.Fatal(err)
	}
	for _, pol := range aclPolList {
		Log("== policy=%v err=%v\n\n", pol, err)

		// Skipping marked policy
		if aclPol[pol.Name].Descr == sKip {
			Log("Skipping policy %q\n", pol.Name)
			continue
		}

		// Removing unknown policy
		if aclPol[pol.Name].Name == "" {
			if _, err := acl.PolicyDelete(pol.ID, nil); err != nil {
				log.Fatalf("%v: %q\n", err, pol)
			} else {
				fmt.Printf("Removed policy %q\n", pol.Name)
			}
			continue
		}

		aclPol1[pol.Name] = pol.ID

		change := ""
		// Updating policy
		if pol.Rules != aclPol[pol.Name].Rules {
			change = "Rules '" + pol.Rules + "' => '" + aclPol[pol.Name].Rules + "'"
			pol.Rules = aclPol[pol.Name].Rules
		}
		if pol.Description != aclPol[pol.Name].Descr {
			change += "Description '" + pol.Description + "' => '" + aclPol[pol.Name].Descr + "'"
			pol.Description = aclPol[pol.Name].Descr
		}
		if change != "" {
			_, _, err := acl.PolicyUpdate(pol, nil)
			if err != nil {
				log.Fatal(err)
				log.Fatalf("%v: %q\n", err, pol)
			} else {
				fmt.Printf("Updated policy %q (%s)\n", pol.Name, change)
			}
		}
		delete(aclPol, pol.Name)
	}

	// Creating absent policies
	for k, v := range aclPol {
		if aclPol[k].Descr == sKip {
			Log("Skipping policy %q\n", k)
			continue
		}
		_, _, err := acl.PolicyCreate(&api.ACLPolicy{Name: k, Rules: v.Rules, Description: v.Descr}, nil)
		if err != nil {
			log.Fatalf("%v: %q\n", err, v)
		} else {
			fmt.Printf("Created policy %q\n", k)
		}
	}
	Log("\n")

	// ===========================================================
	// Role
	// ===========================================================
	aclRole1 := map[string]string{}
	aclRoleList, wm, err := acl.RoleList(nil)
	if err != nil {
		log.Fatal(err)
	}
	Log("==== acl.RoleList %v %v %v\n", aclRoleList, wm, err)
	for _, role := range aclRoleList {
		role, _, err := acl.RoleRead(role.ID, nil)
		Log("== role=%v err=%v\n\n", role, err)

		// Skipping marked role
		if aclRole[role.Name].Descr == sKip {
			Log("Skipping role %q\n", role.Name)
			continue
		}

		// Removing unknown role
		if aclRole[role.Name].Name == "" {
			if _, err := acl.PolicyDelete(role.ID, nil); err != nil {
				log.Fatalf("%v: %q\n", err, role)
			} else {
				fmt.Printf("Removed role %q\n", role.Name)
			}
			continue
		}

		aclRole1[role.Name] = role.ID

		// Creating policy list to comapre
		pl := []string{}
		for _, p := range role.Policies {
			pl = append(pl, p.Name)
		}
		sort.Strings(pl)
		sort.Strings(aclRole[role.Name].Policies)

		// Updating role
		if reflect.DeepEqual(pl, aclRole[role.Name].Policies) == false || role.Description != aclRole[role.Name].Descr {
			role.Policies = CreatePolicyRoleList(aclPol1, aclRole[role.Name].Policies)
			role.Description = aclRole[role.Name].Descr
			_, _, err := acl.RoleUpdate(role, nil)
			if err != nil {
				log.Fatal(err)
				log.Fatalf("%v: %q\n", err, role)
			} else {
				fmt.Printf("Updated role %q\n", role.Name)
			}
		}
		delete(aclRole, role.Name)
	}

	// Creating absent roles
	for k, v := range aclRole {
		if aclRole[k].Descr == sKip {
			Log("Skipping role %q\n", k)
			continue
		}
		poList := CreatePolicyRoleList(aclPol1, v.Policies)
		_, _, err := acl.RoleCreate(&api.ACLRole{Name: k, Policies: poList, Description: v.Descr}, nil)
		if err != nil {
			log.Fatal(err)
			log.Fatalf("%v: %q\n", err, v)
		} else {
			fmt.Printf("Created role %q\n", k)
		}
	}
	Log("\n")

	// ===========================================================
	// Token
	// ===========================================================
	aclToken1 := map[string]string{}
	aclTokenList, wm, err := acl.TokenList(nil)
	if err != nil {
		log.Fatal(err)
	}
	Log("==== acl.TokenList %v %v %v\n", aclTokenList, wm, err)
	for _, token := range aclTokenList {
		token, _, err := acl.TokenRead(token.AccessorID, nil)
		Log("== token=%v err=%v\n\n", token, err)

		// Skipping marked token
		if aclToken[token.Description].Token == sKip || token.Description == sTokMaster || token.Description == sTokAnon {
			Log("Skipping token %q\n", token.Description)
			delete(aclToken, token.Description)
			continue
		}

		// Removing unknown and legacy tokens
		if aclToken[token.Description].Descr == "" || len(token.Rules) > 0 {
			if _, err := acl.TokenDelete(token.AccessorID, nil); err != nil {
				log.Fatalf("%v: %q\n", err, token)
			} else {
				fmt.Printf("Removed token %q\n", token.Description)
			}
			continue
		}

		aclToken1[token.Description] = token.AccessorID

		// Creating policy list to comapre
		pl := []string{}
		for _, p := range token.Policies {
			pl = append(pl, p.Name)
		}
		sort.Strings(pl)
		sort.Strings(aclToken[token.Description].Policies)
		Log("=== pl %q %q %q %q\n\n", pl, aclToken[token.Description].Policies, token.Description, aclToken[token.Description].Descr)
		// Updating token's policy list
		// if len(token.Policies) != 1 || token.Policies[0].Name != aclToken[token.Description].Policy {
		if reflect.DeepEqual(pl, aclToken[token.Description].Policies) == false || token.Description != aclToken[token.Description].Descr {
			// pl := api.ACLTokenPolicyLink{"", aclToken[token.Description].Policy}
			// token.Policies = []*api.ACLTokenPolicyLink{&pl}
			token.Policies = CreatePolicyRoleList(aclPol1, aclToken[token.Description].Policies)

			if _, _, err := acl.TokenUpdate(token, nil); err != nil {
				// log.Fatalf("len(token.Policies)!=1 %v: %v(%v)\n", err, token.Description, token.AccessorID)
				log.Fatalf("Update token policy %v: %q\n", err, token)
			} else {
				fmt.Printf("Updated token %q(%q) policy to %q\n", token.Description, token.AccessorID, aclToken[token.Description].Policies)
			}
		}
		delete(aclToken, token.Description)
	}

	// Creating absent tokens
	for _, v := range aclToken {
		if v.Token == sKip {
			continue
		}

		poList := CreatePolicyRoleList(aclPol1, v.Policies)
		roList := CreatePolicyRoleList(aclRole1, v.Roles)
		if _, _, err := acl.TokenCreate(&api.ACLToken{AccessorID: v.Token, SecretID: v.Token, Description: v.Descr,
			Policies: poList, Roles: roList}, nil); err != nil {
			log.Fatalf("%v: %v\n", err, v)
		} else {
			fmt.Printf("Created token %q\n", v)
		}
	}
	// Token end

} // main

func PolicyRead(acl *api.ACL) (polList []*api.ACLPolicy, err error) {
	aclPolList, _, e := acl.PolicyList(nil)
	if err = e; e != nil {
		return
	}
	for _, pol := range aclPolList {
		policy, _, e := acl.PolicyRead(pol.ID, nil)
		if err = e; e != nil {
			return
		}
		polList = append(polList, policy)
	}
	return polList, err
}

func CreatePolicyRoleList(prList map[string]string, list []string) []*api.ACLLink {
	pr := []*api.ACLLink{}
	for _, p := range list {
		pr = append(pr, &api.ACLLink{ID: prList[p], Name: p})
	}
	return pr
}

func Log(format string, a ...interface{}) {
	if *iDebug == true {
		fmt.Printf(format, a...)
	}
}
